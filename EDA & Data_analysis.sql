--<<<<<<< EXPLORATORY DATA ANALYSIS >>>>>>>

/*
===============================================================================
Database Exploration
===============================================================================
Purpose:
    - To explore the structure of the database, including the list of tables and their schemas.
===============================================================================
*/

--EXPLORE ALL OBJECTS IN THE DATABSE
SELECT * FROM INFORMATION_SCHEMA.TABLES

--EXPLORE ALL COLUMNS IN THE DATABASE
SELECT * FROM INFORMATION_SCHEMA.COLUMNS

/*
===============================================================================
Dimensions Exploration
===============================================================================
Purpose:
    - To explore the structure of dimension tables.
===============================================================================
*/
-- explore countries our customers belong to
SELECT DISTINCT country FROM gold.dim_customers
order by country

--explore all categories
SELECT DISTINCT category, subcategory, product_name FROM gold.dim_products
order by 1,2,3

/*
===============================================================================
Date Range Exploration 
===============================================================================
Purpose:
    - To determine the temporal boundaries of key data points.
    - To understand the range of historical data.
===============================================================================
*/
---- date of first and last order
select
min(order_date) first_order_date, 
max(order_date) last_order_date,
AGE(MAX(order_date), MIN(order_date)) as order_range
from gold.fact_sales
	
--youngest and oldest customer
select
min(birthdate) as oldest_birthdate,
Extract(year FROM age(now(),min(birthdate))) Oldest_customer,
max(birthdate) as youngest_birthdate,
Extract(year FROM age(now(),max(birthdate))) youngest_customer
from gold.dim_customers


/*
===============================================================================
Measures Exploration (Key Metrics)
===============================================================================
Purpose:
    - To calculate aggregated metrics (e.g., totals, averages) for quick insights.
    - To identify overall trends.
===============================================================================
*/

--TOTAL SALES
--TOTAL QUANTITY
--AVERAGE PRICE
--TOTAL NUMBER OF ORDERS
--TOTAL NUMBER OF DISTINCT ORDERS
--TOTAL NUMBER OF PRODUCTS
--TOTAL NUMBER OF CUSTOMERS
--TOTAL NUMBER OF DISTINCT CUSTOMERS WHO HAVE ORDERED
--TOTAL NUMBER OF CUSTOMERS WHO HAVE ORDERED
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM gold.fact_sales
	UNION ALL
SELECT 'Total Quantity', SUM(quantity)	FROM gold.fact_sales
	UNION ALL
SELECT 'Average Price', round(avg(price),2) FROM gold.fact_sales
	UNION ALL 
SELECT 'Total Num of orders', count(order_number) FROM gold.fact_sales
	UNION ALL 
SELECT 'Total Num of distinct orders', count(distinct order_number) FROM gold.fact_sales
	UNION ALL 
SELECT 'Total num of products', count(product_name) FROM gold.dim_products
		UNION ALL 
SELECT 'Total num of customers', count(distinct customer_key) FROM gold.dim_customers	
		UNION ALL 
SELECT 'Total num of distinct customers who have ordered', count( distinct customer_key) FROM gold.fact_sales
		UNION ALL 
SELECT 'Total num of customers who have ordered', count( customer_key) FROM gold.fact_sales


/*
===============================================================================
Magnitude Analysis
===============================================================================
Purpose:
    - To quantify data and group results by specific dimensions.
    - For understanding data distribution across categories.
===============================================================================
*/

--TOTAL CUSTOMERS BY COUNTRY
SELECT 
	country, 
	count(customer_key) AS total_customers
FROM gold.dim_customers	
GROUP BY country
ORDER BY total_customers DESC

--TOTAL CUSTOMERS BY GENDER
SELECT 
gender,
count(customer_key) AS total_customers
FROM gold.dim_customers	
GROUP BY gender


--TOTAL PRODUCTS BY CATEGORY
SELECT 
	category,
	count(product_key) AS total_products
FROM gold.dim_products
GROUP BY category
ORDER BY total_products DESC

--AVG COST IN EACH CATEGORY
SELECT 
category,
round(avg(cost),0) AS average_cost
FROM gold.dim_products
GROUP BY category
ORDER BY average_cost DESC
	
--TOTAL REVENUE GENERATED BY EACH CATEGORY
SELECT 
category,
sum(sales_amount) AS total_revenue
FROM gold.fact_sales s
LEFT JOIN gold.dim_products p
	on s.product_key = p.product_key
GROUP BY category
ORDER BY total_revenue DESC
	
--TOTAL REVENUE GENERATED BY EACH CUSTOMER
SELECT
c.customer_key,
c.first_name,
c.last_name,
sum(s.sales_amount) as total_revenue
FROM gold.fact_sales s
LEFT JOIN gold.dim_customers c
on c.customer_key = s.customer_key
GROUP BY 
	c.customer_key, c.first_name, c.last_name 
ORDER BY total_revenue DESC
	
--DISTRIBUTION OF SOLD ITEMS ACROSS COUNTRIES
SELECT 
country,
sum(quantity) as sold_items
FROM gold.fact_sales s
LEFT JOIN gold.dim_customers c
on s.customer_key = c.customer_key
GROUP BY country 
ORDER BY sold_items DESC

/*
===============================================================================
Ranking Analysis
===============================================================================
Purpose:
    - To rank items (e.g., products, customers) based on performance or other metrics.
    - To identify top performers or laggards.
===============================================================================
*/
--TOP 5 REVENUE GENERATING PRODUCTS

SELECT 
product_name,
sum(sales_amount) AS total_revenue
FROM gold.fact_sales s
LEFT JOIN gold.dim_products p
on s.product_key = p.product_key
GROUP BY product_name
ORDER BY total_revenue DESC
LIMIT 5


-- 5 worst performing products in terms of sales
SELECT 
product_name,
sum(sales_amount) AS total_revenue
FROM gold.fact_sales s
LEFT JOIN gold.dim_products p
on s.product_key = p.product_key
GROUP BY product_name
ORDER BY total_revenue asc
LIMIT 5

-- TOP 10 CUSTOMERS WHO HAVE GENERATED THE HIGHEST REVENUE
SELECT
c.customer_key,
c.first_name,
c.last_name,
sum(s.sales_amount) as total_revenue
FROM gold.fact_sales s
LEFT JOIN gold.dim_customers c
on c.customer_key = s.customer_key
GROUP BY 
	c.customer_key, c.first_name, c.last_name 
ORDER BY total_revenue DESC
LIMIT 10

-- 3 CUSTOMERS WITH THE FEWEST ORDERS PLACED

SELECT
c.customer_key,
c.first_name,
c.last_name,
count(distinct order_number) as total_orders
FROM gold.fact_sales s
LEFT JOIN gold.dim_customers c
on c.customer_key = s.customer_key
GROUP BY 
	c.customer_key, c.first_name, c.last_name 
ORDER BY total_orders 
LIMIT 3

--===== Advance Analytics=====
/*
===============================================================================
Change Over Time Analysis
===============================================================================
Purpose:
    - To track trends, growth, and changes in key metrics over time.
    - For time-series analysis and identifying seasonality.
    - To measure growth or decline over specific periods.
===============================================================================
*/
--<<<<<<Change over time Analysis>>>>
--sales over years
--total customers over years
--total quantity sold over years



SELECT 
EXTRACT(year from order_date) AS year,
EXTRACT(month FROM order_date) as month,
CAST(DATE_TRUNC('month', order_date) as DATE) AS month_start,
sum(sales_amount) as total_sales,
count(distinct customer_key) as total_customers,
sum(quantity) as total_quantity
FROM gold.fact_sales
WHERE EXTRACT(year from order_date) is not null
group by year, month , month_start
ORDER BY year, month



/*
===============================================================================
Cumulative Analysis
===============================================================================
Purpose:
    - To calculate running totals or moving averages for key metrics.
    - To track performance over time cumulatively.
    - Useful for growth analysis or identifying long-term trends.

===============================================================================
*/

--<<<<cumulative analysis>>>>

-- total sales per month 
--running total of sales 

with monthly_sales as(
			SELECT 
			CAST(DATE_TRUNC('month',order_date) AS DATE) as order_dt,
			sum(sales_amount) as total_sales
			FROM gold.fact_sales
			WHERE CAST(DATE_TRUNC('month',order_date) AS DATE) is not null
			GROUP BY order_dt
			)

select 
order_dt,
total_sales,
sum(total_sales) OVER (ORDER BY order_dt) as running_total_sales
from monthly_sales

/*
===============================================================================
Performance Analysis (Year-over-Year, Month-over-Month)
===============================================================================
Purpose:
    - To measure the performance of products, customers, or regions over time.
    - For benchmarking and identifying high-performing entities.
    - To track yearly trends and growth.
===============================================================================
*/


--analyze the yearly performance of products by comparing their sales to 
--both the avg sales of the product and the previous yearly sales



with sale as (
	
			select product_key,
			EXTRACT(year FROM order_date) AS year,
			sum(sales_amount) as current_sale
			from gold.fact_sales
			group by product_key,
			EXTRACT(year FROM order_date) 
			order by   year,product_key)

SELECT
product_key,
year,
current_sale,
--YOY ANALYSIS
LAG(current_sale) OVER(PARTITION BY product_key ORDER BY year) as previous_year_sale,
current_sale - LAG(current_sale) OVER(PARTITION BY product_key ORDER BY year) diff_previos_sale,
CASE 
	WHEN current_sale - LAG(current_sale) OVER(PARTITION BY product_key ORDER BY year) > 0 THEN 'Increase in sale'
	WHEN current_sale - LAG(current_sale) OVER(PARTITION BY product_key ORDER BY year) < 0 THEN 'Deacrease in sale'
	ELSE 'No change'
END AS previous_sale_change,
	--
round(avg(current_sale) OVER (PARTITION BY product_key),0) as avg_sale,
current_sale - round(avg(current_sale) OVER (PARTITION BY product_key),0) as avg_diff,
CASE 
	WHEN current_sale - round(avg(current_sale) OVER (PARTITION BY product_key),0) = 0 THEN 'average'
	WHEN current_sale - round(avg(current_sale) OVER (PARTITION BY product_key),0) > 0 THEN 'greater than avg'
	ELSE 'less than avg'
END as avg_change
from sale

-- yearly sales growth
 

with monthly_sales as(
			SELECT 
			EXTRACT(year FROM order_date) AS year,
			sum(sales_amount) as total_sales
			FROM gold.fact_sales
			WHERE CAST(DATE_TRUNC('month',order_date) AS DATE) is not null
			GROUP BY  year
			)

select 
year,
total_sales,
(total_sales - lag(total_sales) OVER ( ORDER BY year))*100 / nullif(lag(total_sales) OVER ( ORDER BY year),0)||'%' as growth_percentage
FROM monthly_sales

/*
===============================================================================
Part-to-Whole Analysis
===============================================================================
Purpose:
    - To compare performance or metrics across dimensions or time periods.
    - To evaluate differences between categories..
===============================================================================
*/

-- which category contribute the most to overall sales

WITH category_sales AS (
					SELECT
					p.category,
					sum(s.sales_amount) as total_sales
					FROM gold.fact_sales s
					LEFT JOIN gold.dim_products p
					on s.product_key = p.product_key
					GROUP BY category)

SELECT 
category, 
total_sales,
SUM(total_sales) OVER() as overall_sales,
Round((total_sales /SUM(total_sales) OVER()),3) * 100||'%' as perctage_of_total
FROM category_sales

---- which subcategory contribute the most to overall sales
WITH subcategory_sales AS (
					SELECT
					p.subcategory,
					sum(s.sales_amount) as total_sales
					FROM gold.fact_sales s
					LEFT JOIN gold.dim_products p
					on s.product_key = p.product_key
					GROUP BY subcategory
					)

SELECT 
subcategory, 
total_sales,
SUM(total_sales) OVER() as overall_sales,
Round((total_sales /SUM(total_sales) OVER()),3) * 100||'%' as perctage_of_total
FROM subcategory_sales
ORDER BY 4 DESC

--which country contribute the most to overall sales and overall quantity

WITH country_sales AS (
					SELECT
					country,
					sum(s.sales_amount) as total_sales,
					sum(quantity) as total_quantity
					FROM gold.fact_sales s
					LEFT JOIN gold.dim_customers p
					on s.customer_key = p.customer_key
					WHERE country <> 'n/a'	
					GROUP BY country
								)
	
	SELECT 
country,
total_sales,
SUM(total_sales) OVER() as overall_sales,
Round((total_sales /SUM(total_sales) OVER()),3) * 100||'%' as perctage_of_totalsales,
SUM(total_quantity) OVER() as overall_quantity,
Round((total_quantity /SUM(total_quantity) OVER()),3) * 100||'%' as perctage_of_totalquantity
FROM country_sales
ORDER BY total_sales DESC, total_quantity DESC

-- which country contribute the most to overall customers
WITH country_sales AS (
					SELECT
					country,
					count(s.customer_key) as total_customers
					FROM gold.fact_sales s
					LEFT JOIN gold.dim_customers p
					on s.customer_key = p.customer_key
					WHERE country <> 'n/a'	
					GROUP BY country
								)
	
SELECT 
country,
total_customers,
SUM(total_customers) OVER() as overall_sales,
Round((total_customers /SUM(total_customers) OVER()),3) * 100||'%' as perctage_of_totalcust
FROM country_sales
ORDER BY total_customers DESC

/*
===============================================================================
Data Segmentation Analysis
===============================================================================
Purpose:
    - To group data into meaningful categories for targeted insights.
    - For customer segmentation, product categorization, or regional analysis.
===============================================================================
*/
--segment products into cost ranges and 
--count how many products fall in each segment

WITH product_segment AS(
				SELECT 
				product_key,
				product_name,
				cost,
				CASE 
					WHEN cost < 100 THEN 'below 100'
					WHEN cost BETWEEN 100 AND 500 THEN '100-500'
					WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
					ELSE 'above 1000'
				END as cost_range
				FROM gold.dim_products)

SELECT 
cost_range,
count(product_key) as total_products
FROM product_segment
GROUP BY cost_range
ORDER BY total_products DESC

/* Group customers into 3 segments based on their spending behaviour:
VIP: customer with atleast 12 months of history and spending more than 5000.
Regular: customerwith atleast 12 months of history and spending 5000 or less.
New: customers with a lifespan less than 12 months
and find the total number of cutomers in each group */ 
with cust_lifespan AS(
				SELECT 
				c.customer_key,
				sum(s.sales_amount) as total_sales,
				min(order_date) as min_date,
				max(order_date) as max_date,
				EXTRACT(YEAR FROM AGE(max(order_date), min(order_date))) * 12 + 
       			EXTRACT(MONTH FROM AGE(max(order_date), min(order_date))) AS lifespan
				FROM gold.fact_sales s
				LEFT JOIN gold.dim_customers c
				on c.customer_key = s.customer_key
				GROUP BY c.customer_key)

	SELECT 
				CASE 
					WHEN lifespan >=12 AND total_sales > 5000 THEN 'VIP'
					WHEN lifespan >= 12 AND total_sales <=5000 THEN 'Regular'
					ELSE 'New'
				END as customer_type,
				count(customer_key)
				FROM cust_lifespan
				GROUP BY CASE 
					WHEN lifespan >=12 AND total_sales > 5000 THEN 'VIP'
					WHEN lifespan >= 12 AND total_sales <=5000 THEN 'Regular'
					ELSE 'New'
				END 

